#!/usr/bin/env python

import os
import numpy as np
import matplotlib.pyplot as plt
import tqdm
import torch

from src.gp.GPyModelWrapper import GPyModelWrapper
from src.gp.gp_utils import *
from src.utils.DirectoryConfig import DirectoryConfig as DirConf
from src.gp.GPDataset import GPDataset

def train_MPC_gp(quad_name, model_type, trajectory_name, env, gt, epoch, n_dense_points=None, n_sparse_points=None, n_induce=None, verbose=0,keep_train_data=False):
    """
    Train GP models for MPC model compensation. The trained GP model provides acceleration corrections to the dynamic model for
    improved accuracy of model prediction. 
    The "Exact" model will be trained by training a "dense" model using higher 
    number of n_dense_points, and a "sparse" model with smaller n_sparse_points generated by this dense model. 
    The "Approx" model will be trained with n_dense_points 
    :param quad_name: Name of the quadrotor
    :type quad_name: string
    :param model_type: String value indicating the GP model type ["Exact" or "Approx"]
    :type model_type: string
    :param trajectory_name: The name of the trajectory that was executed to collect flight data
    :type trajectory_name: string
    :param env: String value indicating the environment the quadrotor flight was executed for data collection
    :type env: string
    :param gt: Boolean value to indicate whether groundtruth state measurements were used for flight execution.
    :type gt: Bool
    :param epoch: Number of training epochfor GP training
    :type epoch: Int
    :param n_dense_points: Integer value indicating number of points utilized for Exact Dense GP training
    :type n_dense_points: Int
    :param n_sparse_points: Integer value indicating number of points utilized for Exact Sparse GP training
    :type n_sparse_points: Int
    :param n_induce: Number of inducing points for Approx GP model types
    :type n_induce: Int
    """
    assert model_type in ["Exact", "Approx"]
    load_model = False

    # Load Dataset
    flight_name = "%s_mpc%s_%s"%(env, "_gt" if gt else "", quad_name)
    results_dir = os.path.join(DirConf.FLIGHT_DATA_DIR, flight_name, trajectory_name)
    x_features_idx = [7, 8, 9]
    y_features_idx = [7, 8, 9]
    gp_ds = GPDataset(results_dir)

    # Select data points to be used
    if n_dense_points is not None:
        x_train = np.zeros((len(x_features_idx), n_dense_points))
        y_train = np.zeros((len(x_features_idx), n_dense_points))
    else:
        x_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
        y_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
    for i, (xi, yi) in enumerate(zip(x_features_idx, y_features_idx)):
        train_in, train_out = gp_ds.get_train_ds(xi, yi)
        if n_dense_points is not None:
            selected_idx =  distance_maximizing_points_1d(train_in, n_dense_points)
            x_train[i, :] = np.squeeze(train_in[selected_idx])
            y_train[i, :] = np.squeeze(train_out[selected_idx])
        else:
            x_train[i, :] = np.squeeze(train_in)
            y_train[i, :] = np.squeeze(train_out)
    x_train = torch.Tensor(x_train.T)
    y_train = torch.Tensor(y_train.T)

    # Create GP Model
    model_name = "%s_%s_mpc_%d%s"%("e" if model_type == "Exact" else "a", 
                                   quad_name, 
                                   n_dense_points if n_dense_points is not None else -1, 
                                   "" if model_type == "Exact" else "-%d"%n_induce)
    gp_model = GPyModelWrapper(model_type, model_name, load=load_model, x_features=x_features_idx, y_features=y_features_idx, keep_train_data=keep_train_data)
    gp_model.train(x_train, y_train, epoch, induce_num=n_induce, verbose=verbose, script_model=False if model_type=="Exact" else True)

    x, y = gp_ds.get_train_ds()
    x = torch.Tensor(x[:, x_features_idx])
    y = torch.Tensor(y[:, y_features_idx])
    gp_model.visualize_model(x, y)
    
    if model_type == "Exact":
        # Select sparse data points to be used
        x_train = np.zeros((len(x_features_idx), n_sparse_points))
        y_train = np.zeros((len(x_features_idx), n_sparse_points))
        for i, (xi, yi) in enumerate(zip(x_features_idx, y_features_idx)):
            train_in, _ = gp_ds.get_train_ds(xi, yi)
            x_train[i, :] =  distance_maximizing_points_1d(train_in, n_sparse_points, dense_gp=gp_model)
        x_train = x_train.T
        _, y_train = gp_model.predict(x_train, skip_variance=True)
        x_train = torch.Tensor(x_train)
        y_train = torch.Tensor(y_train)
        # Create Dense GP Model
        s_model_name = "%s_%s_mpc_%d"%("e", 
                                       quad_name, 
                                       n_sparse_points)
        gp_model = GPyModelWrapper(model_type, s_model_name, load=load_model, x_features=x_features_idx, y_features=y_features_idx, keep_train_data=keep_train_data)
        gp_model.train(x_train, y_train, epoch, induce_num=n_induce, dense_model_name=model_name, verbose=verbose, script_model=True)
        gp_model.visualize_model(x, y)
        
    return gp_model

def train_MHE_gp(quad_name, model_type, trajectory_name, env, epoch, n_dense_points=None, n_sparse_points=None, n_induce=None, verbose=0, keep_train_data=False):
    """
    Train GP models for D-MHE model compensation. The trained GP model provides acceleration corrections to the dynamic model for
    improved accuracy of model prediction. 
    The "Exact" model will be trained by training a "dense" model using higher 
    number of n_dense_points, and a "sparse" model with smaller n_sparse_points generated by this dense model. 
    The "Approx" model will be trained with n_dense_points 
    :param quad_name: Name of the quadrotor
    :type quad_name: string
    :param model_type: String value indicating the GP model type ["Exact" or "Approx"]
    :type model_type: string
    :param trajectory_name: The name of the trajectory that was executed to collect flight data
    :type trajectory_name: string
    :param env: String value indicating the environment the quadrotor flight was executed for data collection
    :type env: string
    :param epoch: Number of training epochfor GP training
    :type epoch: Int
    :param n_dense_points: Integer value indicating number of points utilized for Exact Dense GP training
    :type n_dense_points: Int
    :param n_sparse_points: Integer value indicating number of points utilized for Exact Sparse GP training
    :type n_sparse_points: Int
    :param n_induce: Number of inducing points for Approx GP model types
    :type n_induce: Int
    """
    assert model_type in ["Exact", "Approx"]
    load_model = False

    # Load Dataset
    flight_name = "%s_dmhe_%s"%(env, quad_name)
    results_dir = os.path.join(DirConf.FLIGHT_DATA_DIR, flight_name, trajectory_name)
    x_features_idx = [6, 7, 8]
    y_features_idx = [7, 8, 9]
    gp_ds = GPDataset(results_dir)
    
    # Select data points to be used
    if n_dense_points is not None:
        x_train = np.zeros((len(x_features_idx), n_dense_points))
        y_train = np.zeros((len(x_features_idx), n_dense_points))
    else:
        x_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
        y_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
    for i, (xi, yi) in enumerate(zip(x_features_idx, y_features_idx)):
        train_in, train_out = gp_ds.get_train_ds(xi, yi)
        if n_dense_points is not None:
            selected_idx =  distance_maximizing_points_1d(train_in, n_dense_points)
            x_train[i, :] = np.squeeze(train_in[selected_idx])
            y_train[i, :] = np.squeeze(train_out[selected_idx])
        else:
            x_train[i, :] = np.squeeze(train_in)
            y_train[i, :] = np.squeeze(train_out)
    x_train = torch.Tensor(x_train.T)
    y_train = torch.Tensor(y_train.T)

    # Create GP Model
    model_name = "%s_%s_mhe_%d%s"%("e" if model_type == "Exact" else "a", 
                                   quad_name, 
                                   n_dense_points if n_dense_points is not None else -1, 
                                   "" if model_type == "Exact" else "-%d"%n_induce)
    gp_model = GPyModelWrapper(model_type, model_name, load=load_model, x_features=x_features_idx, y_features=y_features_idx, mhe=True, keep_train_data=keep_train_data)
    gp_model.train(x_train, y_train, epoch, induce_num=n_induce, verbose=verbose, script_model=False if model_type=="Exact" else True)

    x, y = gp_ds.get_train_ds()
    x = torch.Tensor(x[:, x_features_idx])
    y = torch.Tensor(y[:, y_features_idx])
    gp_model.visualize_model(x, y)

    # Train Sparse Model for Exact GP
    if model_type == "Exact":
        # Select sparse data points to be used
        x_train = np.zeros((len(x_features_idx), n_sparse_points))
        y_train = np.zeros((len(x_features_idx), n_sparse_points))
        for i, (xi, yi) in enumerate(zip(x_features_idx, y_features_idx)):
            train_in, _ = gp_ds.get_train_ds(xi, yi)
            x_train[i, :] =  distance_maximizing_points_1d(train_in, n_sparse_points, dense_gp=gp_model)
        x_train = x_train.T
        _, y_train = gp_model.predict(x_train, skip_variance=True)
        x_train = torch.Tensor(x_train)
        y_train = torch.Tensor(y_train)
        # Create Dense GP Model
        s_model_name = "%s_%s_mhe_%d"%("e", 
                                       quad_name, 
                                       n_sparse_points)
        gp_model = GPyModelWrapper(model_type, s_model_name, load=load_model, x_features=x_features_idx, y_features=y_features_idx, mhe=True, keep_train_data=keep_train_data)
        gp_model.train(x_train, y_train, epoch, induce_num=n_induce, dense_model_name=model_name, verbose=verbose, script_model=True)
        gp_model.visualize_model(x, y)
        
    return gp_model

if __name__ == "__main__":
    quad_name = "clara"
    model_type = "Approx"
    trajectory_name = "circle"
    environment = "arena"
    gt = False
    mpc_epoch = 1000
    mhe_epoch = 500
    n_dense_points = None
    n_sparse_points = n_induce = 20
    verbose = 1
    keep_train_data = True
    train_mpc = False
    train_mhe = True
    if train_mpc:
        train_MPC_gp(quad_name, 
                    model_type, 
                    trajectory_name, 
                    environment, 
                    gt, 
                    mpc_epoch, 
                    n_dense_points=n_dense_points, 
                    n_sparse_points=n_sparse_points, 
                    n_induce=n_induce,
                    verbose=verbose,
                    keep_train_data=keep_train_data)
    if train_mhe:
        train_MHE_gp(quad_name,
                    model_type,
                    trajectory_name,
                    environment,
                    mhe_epoch,
                    n_dense_points=n_dense_points,
                    n_sparse_points=n_sparse_points,
                    n_induce=n_induce,
                    verbose=verbose,
                    keep_train_data=keep_train_data)
